extends ../layouts/blog.pug

block page_infos
  -var title = ""
  -var description = ""
  -var date = "Jan 07 2017"

block content

  :markdown-it(linkify langPrefix='highlight-')

    # Psychedelic: Minha Stack para blogs estáticos, single page, hybrid Style e Offline first.

    - Não é tutorial
    - Link do projeto finalisado
    - Você está navegando nele ;)
    - Listar Stack
    - Nível intermediario
    - Conhecimento prévio de pug (jade), npm, gulp

    ## Motivação

    Meu [antigo site](https://github.com/afonsopacifer/my-personal-website) era lindo, utilizava coisas muitos legais como Jade, [PostCSS](http://postcss.org/) e um sistema engenhoso de configuração utilizando arquivos JSON, além de possuir uma stack de testes redondinha com [Karma](https://karma-runner.github.io/1.0/index.html) e seus amigos. Mesmo consumindo os dados de um JSON e gerando as paginas estáticas, tive um grande problema em manter tudo atualizado pois utilizava imagens para cada novo item inserido (eu preciso inserir muita coisa rs), além disso ficou pesado e a complexidade do CSS quase me fez perder o controle (só não perdi pq o [Atomic Design](http://bradfrost.com/blog/post/atomic-web-design/) não deixou &lt;3).

    ### O Problema da Stack antiga

    Nenhuma, mas eu tomei a decisão de criar um boilerplate antes de construir o site, o que gerou muita coisa desnecessária (testes em um site estático foi bizarro) e somado as decisões de de design fizeram o meu site ficar bem desatualizado ao longo dos meses, a solução para mim era obvia, jogar tudo fora e começar do zero, mas dessa vez iria criar primeiro o site e depois extrair um boilerplate.

    > O boilerplate citado acima é o [slush-tangerine](https://github.com/afonsopacifer/slush-tangerine) e está disponível no [npm](https://www.npmjs.com/package/slush-tangerine) e [github](https://github.com/afonsopacifer/slush-tangerine) ;)

    ### Novas decisões

    Aproveitando que iria reescrever tudo, apesar de não ter mais do que algumas horas antes de dormir por uns dias para faze-lo, decidi continuar com o esquema de gerar tudo estático mas dessa vez queria criar uma [SPA](https://en.wikipedia.org/wiki/Single-page_application) (Single Page Application) que deveria ser [Offline First](http://offlinefirst.org/), até porque, estamos no século XXI né lek rsrs.

    ## Template engine e estrutura básica com Pug

    Como não tinha o que reclamar do meu template engine favorito Jade, continue porém com seu novo nome, [Pug](https://pugjs.org/api/getting-started.html). Aqui inspirado pela arquitetura do [Jekyll](https://jekyllrb.com/) usei a seguinte estrutura.

    ![Rascunho da estrutura básica do do projeto com pug](/assets/img/posts/psychedelic/psychedelic-pug.jpg)

    - `assets/` - Todas as imagens, `.svg`, `.css` (compilado), `.js`(compilado), etc...
    - `src/` - Arquivos `.pug`, `.bnn` e `.js`(es6)
    - `src/blog/` - Todos os artigos do blog.
    - `src/blog/post.pug` - Exemplo de artigo.
    - `src/includes/` - Partes reutilizavéis do projeto, como `header`, `aside`, etc...
    - `src/layouts/` - Templates básicos do projeto.
    - `src/scripts/` - Arquivos `.js` antes de serem trasnpilados.
    - `src/styles/` - Arquivos `.bnn` antes de serem compilados para `.css`.
    - `src/index.pug` - Página inicial.
    - `post.html` - Exemplo de artigo compilado.
    - `index.html` - Página inicial compilada.

    Como temos a estrutura das páginas separadas nas pastas `layouts/` e `includes/`, podemos construir nosso `index.pug` e as demais paginas focando apenas no conteúdo, algo assim:

    ```pug
    extends ./layouts/default.pug

    block page_infos
      -var title = &quot;Título da página&quot;
      -var description = &quot;Exemplo de descrição&quot;

    block content

      h1 Hello Psychedelic
    ```

    > Usamos as variáveis `title` e `description` para informar ao template quais são as informações especificas sobre a página para montar seus meta dados corretamente &lt;3

    Com essa estrutura eu já temos o poder de organizar muito bem o projeto. Adicionand o bom e velho de guerra [Gulp](http://gulpjs.com/) usando o [gulp-pug](https://github.com/pugjs/gulp-pug), para dar watch e fazer os builds, temos práticamente um gerador estático pronto para ação.

    ## Base da dados estática com json + gulp-data

    Como toda boa aplicação, precisamos construir e consumir nossos dados para montar as views, nesse caso como além de blog temos um site pessoal, nossos dados são:

    - Lista de [artigos](https://github.com/afonsopacifer/afonsopacifer.github.io/blob/master/data-base/articles.json)
    - Lista de [palestras](https://github.com/afonsopacifer/afonsopacifer.github.io/blob/master/data-base/talks.json)
    - Lista de [videos](https://github.com/afonsopacifer/afonsopacifer.github.io/blob/master/data-base/videos.json)
    - Lista de [projetos](https://github.com/afonsopacifer/afonsopacifer.github.io/blob/master/data-base/projects.json)

    ### **Criando** a base de dados


    // <p>Cada lista tem seus tipos de dados específicos, para organizar isso tudo, criamos a pasta <code>data-base</code>
    // e lá dentro criamos os <a href="https://github.com/afonsopacifer/afonsopacifer.github.io/tree/master/data-base">arquivos JSON</a> contendo esses dados, dessa forma para adicionar, por exemplo, um video a base de dados, basta editar o JSON correspondente e temos um <strong>update</strong>.</p>
    //
    // <h3><strong>Consumindo</strong> a base de dados</h3>
    // <p>Para consumir o conteúdo dos arquivos JSON e deixa-los disponíveis para exibição, vamos utilizar o <a href="https://github.com/colynb/gulp-data">gulp-data</a>, basta adiciona-lo a pipeline do Gulp e apontar para os arquivos a serem lidos.</p>
    // <pre><code class="highlight-js">gulp.task('pug', () =&gt; {
    //   gulp.src(['src/**.pug','src/blog/**.pug'])
    //     .pipe(data(file =&gt; require('./data-base/talks.json')))
    //     .pipe(data(file =&gt; require('./data-base/projects.json')))
    //     .pipe(data(file =&gt; require('./data-base/articles.json')))
    //     .pipe(data(file =&gt; require('./data-base/videos.json')))
    //     .pipe(pug())
    //     .pipe(gulp.dest('./'))
    //     .pipe(connect.reload());
    // });
    // </code></pre>
    // <p>Pronto, temos nossos dados disponíveis na aplicação.</p>
    // <h3><strong>Exibindo</strong> os dados com Pug</h3>
    // <p>Com os dados disponíveis precisamos apenas <strong>itera-los</strong> utilizando um simples <code>for</code>, assim exibimos a lista de dados vindas do JSON e compilados tudo para suas respectivas paginas html <strong>estáticas</strong>.</p>
    // <p>Criamos os arquivos <code>.pug</code> em <code>src/</code> para cada pagina que iremos criar e iteramos em seus respectivos dados como no exemplo abaixo.</p>
    // <pre><code class="highlight-pug">for video16 in videos_2016
    //   article
    //     span=video16.date
    //     a(href=video16.url)
    //       h3=video16.theme
    //     a(href=video16.url)
    //       |Duration #{span=video16.time} [#{span=video16.lang}]
    // </code></pre>
    // <blockquote>
    // <p><strong>Tip:</strong> Na listagem de posts, podemos usar um <code>if</code> para filtrar um artigo especificado como &quot;draft&quot; por exemplo.</p>
    // </blockquote>
    // <pre><code class="highlight-pug">for post16 in articles_2016
    //   if !post16.draft
    // </code></pre>
    // <h2>Blog posts em markdown com jstransformer</h2>
    // <h2>Single Page App com sennaJS</h2>
    // <ul>
    // <li>Pug + sennajs</li>
    // </ul>
    // <h2>Offline First com Service Workers</h2>
    // <ul>
    // <li>sw</li>
    // <li>babel</li>
    // </ul>
    // <h2>Estilo hibrido com bananacss</h2>
    // <blockquote>
    // <p>O que é <a href="https://github.com/bananacss/bananacss">bananacss</a>?</p>
    // <p>É um <strong>superset CSS</strong> feito em Node.js por mim (rs), que permite escrever seus estilos usando uma melhor <strong>code UI</strong> através de <strong>abstrações</strong> simples, além de todos os poderes de um <strong>pré-processador</strong> comum, como: Variáveis, funções, modules, etc…</p>
    // </blockquote>
    // <p>Banana é focado na <strong>plataforma</strong>, logo, em tudo o que faz sentido ele utiliza a <strong>syntax default do CSS</strong> e compila para algo que os &quot;browsers atuais&quot; suportam, o que é complexo e não faz diferença usar com a syntax nativa ele trás abstrações através das <strong>propriedades bananais</strong>.</p>
    // <p>O diferencial aqui, é que vamos usa-lo como <strong>pré-processador híbrido</strong>, isso porque vamos compilar tudo normalmente porém não vamos compilar as variáveis, como ele usa a syntax de <strong>variáveis nativas</strong> do CSS, vamos deixalas intactas para usa-las de forma dinâmica mais tarde.</p>
    // <p>Para fazer isso vamos utilizar o plugin <a href="https://github.com/bananacss/gulp-banana">gulp-banana</a> e passar como parâmetro nossas configuração personalizada.</p>
    // <pre><code class="highlight-js">gulp.task('banana', () =&gt; {
    //   gulp.src('src/styles/main.bnn')
    //     .pipe(banana({
    //       bnnVariable : false,
    //       compress : true
    //     }))
    //     .pipe(gulp.dest('assets/styles/'))
    //     .pipe(connect.reload());
    // });
    // </code></pre>
    // <p>Dessa forma temos nosso estilo híbrido, com poderes de pré-processador porém usando partes totalmente nativas.</p>
    // <h2>Psicodelia com CSS Variables + Forgotten Events</h2>
    // <ul>
    // <li>CSS Variables</li>
    // <li>Mouse</li>
    // <li>Ambient Light API</li>
    // </ul>
    // <h2>Coisinhas</h2>
    // <ul>
    // <li>emojicss</li>
    // <li>disqus no layout</li>
    // </ul>
    // <h2>Build e Deploy</h2>
    // <h2>Bonûs</h2>
    // <ul>
    // <li>Boilerplate com Stcak isolada para estudos.</li>
    // </ul>
